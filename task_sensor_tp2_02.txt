task_sensor.txt — Análisis y descripción (TP2-01-12)

Descripción del módulo
--------------------
Es la parte del “Sensor Statechart” para 1 botón (BTN_A). Lee el pin del botón,
convierte eso en eventos (UP/DOWN) y, según el estado, avisa a la tarea System.
Se ejecuta de forma no bloqueante, usando un tick de 1 ms.

Tipos y estructuras (task_sensor_attribute.h)
---------------------------------------------
• Eventos del botón (task_sensor_ev_t): EV_BTN_XX_UP, EV_BTN_XX_DOWN.
• Estados (task_sensor_st_t): ST_BTN_XX_UP, ST_BTN_XX_FALLING,
  ST_BTN_XX_DOWN, ST_BTN_XX_RISING.
• ID del sensor: task_sensor_id_t { ID_BTN_A }.

• Configuración por sensor (task_sensor_cfg_t):
  - identifier (ID del botón),
  - gpio_port y pin (dónde está conectado),
  - pressed (nivel lógico que significa “apretado”),
  - tick_max (valor de carga para temporización),
  - signal_up y signal_down (eventos que se mandan a System).

• Datos por sensor (task_sensor_dta_t):
  - tick (contador interno),
  - state (estado actual),
  - event (último evento leído).

Constantes (task_sensor.c)
--------------------------
G_TASK_SEN_CNT_INIT = 0,
G_TASK_SEN_TICK_CNT_INI = 0,
DEL_BTN_XX_MIN = 0,
DEL_BTN_XX_MED = 25,
DEL_BTN_XX_MAX = 50.
Sirven para iniciar contadores y para temporización (antirrebote/hover).

Tablas (arrays)
---------------
• Configuración (1 entrada):
  task_sensor_cfg_list[] = { ID_BTN_A, puertos/pin de BTN_A, nivel “pressed”,
  tick_max = DEL_BTN_XX_MAX, y los señales a System }.

• Datos (1 entrada):
  task_sensor_dta_list[] = { tick = 0, estado inicial = ST_BTN_XX_UP,
  evento inicial = EV_BTN_XX_UP }.

Variables globales
------------------
g_task_sensor_cnt (cuántas veces corrió la tarea) y
g_task_sensor_tick_cnt (ticks pendientes para ejecutar la tarea).

Funciones principales
---------------------
1) task_sensor_init(void*)
   - Imprime por logger que la tarea empezó.
   - Pone contadores en cero.
   - Para cada sensor: estado = UP, evento = UP, tick = 0.

2) task_sensor_update(void*)
   - Revisa si hay ticks pendientes (g_task_sensor_tick_cnt > 0).
   - Si hay, consume uno y ejecuta el statechart.
   - Si quedaron más ticks, vuelve a consumir (while) hasta ponerse al día.
   - Todo sin bloquear (usa secciones críticas cortas para el contador de ticks).

3) task_sensor_statechart(void)
   - Por cada sensor:
     * Lee el pin con HAL_GPIO_ReadPin().
       Si coincide con “pressed” → evento = DOWN; si no → UP.
     * Según el estado:
       - ST_BTN_XX_UP: si llega DOWN → manda señal “signal_down” a System
         y pasa a ST_BTN_XX_DOWN.
       - ST_BTN_XX_DOWN: si llega UP → manda “signal_up” a System
         y pasa a ST_BTN_XX_UP.
       - ST_BTN_XX_FALLING / ST_BTN_XX_RISING: en este código están vacíos.
     * Si algo raro pasa, reinicia: tick = 0, estado = UP, evento = UP.

Relación con el diagrama (task_sensor.png)
------------------------------------------
El diagrama tiene 4 estados: UP, FALLING, DOWN y RISING.
La idea es que en los flancos se cargue “tick = DEL_BTN_XX_MAX” y luego,
mientras tick > 0, se queda en FALLING/RISING decrementando tick.
Cuando tick llega a 0 se habilita el cambio definitivo (a DOWN o a UP) y
se envía el evento a System.

En el código actual se implementa la versión simple: se pasa UP ↔ DOWN
directamente (sin usar FALLING/RISING ni el tick interno). El resto está
preparado (tipos y campos) por si se quiere completar el antirrebote con tick.

Análisis de g_app_runtime_us (Application Runtime, µs)

Qué es
g_app_runtime_us es el tiempo total que tarda “la app” en cada ciclo de actualización. Arranca en 0 al comienzo del ciclo y se va sumando con lo que tarda cada tarea (Sensor, System, Actuator). Al terminar el ciclo queda el valor acumulado de ese ciclo. En el siguiente ciclo vuelve a 0 y repite.

Lo que observé
- En reposo (sin tocar botones) el valor típico quedó alrededor de 18–22 µs (en mi caso ~20 µs).
- Cuando presiono un botón, puede variar un poco (por el antirrebote y los eventos), pero en general se mantiene en el mismo orden de magnitud.
- Cada vez que corre un ciclo, lo veo reiniciar a 0 y luego subir hasta el número final de ese ciclo.

Qué cosas lo hacen subir
- Si la tarea Sensor hace más trabajo (por ejemplo, FALLING/RISING con tick decrementando), suma algunos microsegundos.
- Si hay mensajes por LOGGER dentro de las tareas, el tiempo aumenta bastante (la UART y los prints agregan costo).
- Pausas del debugger o breakpoints alteran la medición (conviene mirar con el programa corriendo).

Relación con el WCET
El WCET es un “máximo histórico” por tarea; en cambio g_app_runtime_us es el total de ese ciclo actual. Por eso g_app_runtime_us puede cambiar ciclo a ciclo, mientras el WCET solo sube cuando aparece un caso peor.

Conclusión
g_app_runtime_us refleja el “peso” del trabajo de la app en cada iteración: empieza en 0, suma Sensor→System→Actuator y queda en un valor que, en mi placa, ronda ~20 µs en condiciones normales. Si activo logs o genero muchos flancos en los botones, el número sube un poco; si no, se mantiene bastante estable.
